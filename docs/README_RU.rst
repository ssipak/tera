Tera Templates
==============

Описание
^^^^^^^^

Tera Templates - javascript-шаблонизатор, подключаемый как плагин jQuery 1.7.

Предназначен для быстрой подстановки большого объёма данных в шаблон.

Поддерживает сложные подстановки, условные конструкции и циклы.

Компилирует каждый шаблон в простую функцию javascript при первом использовании.

При повторном использовании шаблона используется скомпилированная функция.

Синтаксис
^^^^^^^^^

Вызов основной функции шаблонизатора в javascript-коде::

  var result = $.tera(template, data);

, где ```template``` - это строка, содержащая текст шаблона,
```data``` - данные, которые будут подставлены в этот шаблон.
Функция вернёт результат подстановки данных в шаблон как строку.

Подстановки
-----------

С экранированием:

``{var}``
    data['var'] - простая подстановка.
``{var.key.subkey}``
    data['var']['key']['subkey'] - сложная подстановка.
``{var1.key1[var2.key2]}``
    data['var1']['key1'][ data['var2']['key2'] ] - вложенная подстановка.
``{<}``
    { - открывающая фигурная скобка
``{>}``
    } - закрывающая фигурная скобка
``{$}``
    Знак ```$``` принимает разные значения в зависимости от контекста.
    Если он используется вне циклов, то ссылается непосредственно на данные,
    переданные в шаблон. Если знак используется внутри цикла,
    то ссылается на текущий элемент массива или текущее свойство объекта.
    Знак можно использовать в сложной подстановке: ``{$.key.subkey}``.
``{json var}``
    json(data['var']) подстановка переменной, представленной в формате JSON
``{esc var}``
    Явное экранирование. В том числе позволяет вставить данные по зарезервированным ключам

Без экранирования:

``{raw var}``
    Обычная подстановка без экранирования
``{raw-json}``
    Подстановка данных в JSON формате без экранирования


Условные конструкции
--------------------

Простейшие условные конструкции состоят из открывающего и закрывающего тэгов
и контента между тэгами:

+ {if var}
  этот текст подставится в шаблон,
  если var определена и приводится к true
  {/if}
+ {if-not var}
  этот текст подставится в шаблон,
  если var не определена или приводится к false
  {/if}
+ {unless var}
  это условие аналогично {if-not}{/if}
  {/unless}

В условии может быть выражение любой сложности, допустима группировка круглыми скобками::

  {if var >= 9 && var < 12} var в диапозоне [9, 12)! {/if}

Поддерживаемые операции::

  == (равно), != (не равно),
  < (меньше), > (больше), <= (меньше или равно), >= (больше или равно),
  && (логическое и), || (логическое или),
  + (сложение), - (вычитание)

В условных конструкциях можно использовать else и else-if/else-unless
и сложные подстановки::

  {city.name} &mdash;
  {if city.name == 'Москва'}
      порт семи морей
  {else-if city.name == 'Киев'}
      мать городов русских
  {else-unless city.name == 'Владивосток'}
      какой-то город, но точно не Владивосток
  {/if}

Шаблонизатор понимает специальну конструкцию if[-not]-empty,
которая позволяет определить, пустой ли масси или объект.
Объект считается пустым, если у него нет ни одного собственного свойства.

``{if-empty list} В списке list нет ни одного пункта {/if}``

Циклы
-----

Цикл позволяет пройтись по всем элементам массива или по всем собственным свойствам объекта.
Общий синтаксис цикла::

  {each [element[ as key][ at index] in ]array_or_hash}
    ...тело цикла...
  {/each}

, где параметры:

+ ``element`` (``$``) - очередной элемент массива или свойство объекта;
+ ``key`` (``$k``) - имя свойства или номер элемента массива;
+ ``index`` (``$i``) - порядковый номер элемента или свойства (нумерация начинается с нуля);
+ ``array_or_hash`` (``{$$}``) - итерируемый массив или объект.

В теле цикла доступны специальные условные конструкции:

+ ``{if-first} если текущий элемент/свойство первый в массиве/объекте, то этот текст появится в результате {/if}``
+ ``{if-last} если текущий элемент/свойство последний в массиве/объекте, то этот текст появится в результате {/if}``

Простейший пример использования цикла для вывода массива как HTML-списка::

  <ul>
    {each array}
      <li>{$}</li>
    {/each}
  </ul>

При подстановке данных ['первый элемент',2,'<b>третий элемент</b>'] в шаблон, получим::

  <ul>
      <li>первый элемент</li>
      <li>2</li>
      <li><b>третий элемент</b></li>
  </ul>

Во вложенных циклах может потребоваться доступ во внутреннем цикле к значению, индексу или ключу из внешнего цикла.
Для этого достаточно назначить алиасы для интересующих переменных во внешнем цикле и обращаться к ним, используя подстановки::

  data = {
    stations: [
      {name: 'Владивосток', id: 'vl'},
      {name: 'Нью-Йорк',    id: 'ny'},
      {name: 'Париж',       id: 'pa'}
    ],
    distance: {
      vl: {vl: 0,   ny: 10, pa: 100},
      ny: {vl: 10,  ny: 0,  pa: 80},
      pa: {vl: 100, ny: 80, pa: 0}
    }
  };

  <h1>Расстояние между населенными пунктами</h1>
  <table>
    <tr>
      <td />
      {each stations}
        <td>{$.name}</td>
      {/each}
    </tr>
    {each station in stations}
      <tr>
        <td>{$.name}</td>
        {each stations}
          <td>{distance[$.id][station.id]}</td>
        {/each}
      </tr>
    {/each}
  </table>

Пример выводит табличку с расстояниями между городами.

Доступ к шаблону по атрибуту ID
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

После того, как DOM документа построен, селектором ``script[type="text/template-tera"]`` выбираются элемент,
HTML-содержимое которых затем компилируется как шаблон.

Можно использовать содержимое любого элемента документа как шаблон, если у этого документа указан ID.
Для этого предусмотрена функция::

  var result = $.tera.byId(id, data)

, где ```id``` - значение атрибута ID,
```data``` - данные, которые будут подставлены в этот шаблон.

В шаблон можно подставить другой шаблон::

  {tmpl id var}

, где ``id`` - ID шаблона, ``var`` - переменная, значение которой будет передано в шаблон.
