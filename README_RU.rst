Tera Templates
==============

Описание
^^^^^^^^

Tera Templates - javascript-шаблонизатор, подключаемый как плагин jQuery 1.7.

Предназначен для быстрой подстановки большого объёма данных в шаблон.

Поддерживает сложные подстановки, условные конструкции и циклы.

Компилирует каждый шаблон в простую функцию javascript при первом использовании.

При повторном использовании шаблона используется скомпилированная функция.

Синтаксис
^^^^^^^^^

Основная функция шаблонизатора в javascript-коде вызывается так::

  var result=$.tera(template, data);

, где ```template``` - это строка, содержащая текст шаблона,
```data``` - данные, которые будут подставлены в этот шаблон.
Функция вернёт результат подстановки данных в шаблон как строку.

Подстановки
-----------

Список поддерживаемых подстановок:

``{var}``
    data['var'] - простая подстановка.
``{var.key.subkey}``
    data['var']['key']['subkey'] - подстановка.
``{var1.key1[var2.key2]}``
    data['var1']['key1'][ data['var2']['key2'] ] - сложная подстановка.
``{{}``
    { - открывающая фигурная скобка
``{}}``
    } - открывающая фигурная скобка
``{$}``
    Знак ```$``` принимает разные значения в зависимости от контекста.
    Если он используется вне циклов, то ссылается непосредственно на данные,
    переданные в шаблон. Если знак используется внутри цикла,
    то ссылается на текущий элемент массива или текущее свойство объекта.
    Знак можно использовать в сложной подстановке: ``{$.key.subkey}``.

Условные конструкции
--------------------

Простейшие условные конструкции состоят из открывающего и закрывающего тэгов
и контента между тэгами:

+ {if var}
  этот текст подставится в шаблон,
  если var определена и приводится к true
  {/if}
+ {if-not var}
  этот текст подставится в шаблон,
  если var не определена или приводится к false
  {/if}
+ {unless var}
  это условие аналогично предыдущему
  {/unless}

Можно использовать операции сравнения так же, как их аналоги в javascript::

  {if var >= 9} var больше или равно девяти! {/if}

Поддерживаются операции сравнения:
== (равно), != (не равно) <(меньше), >(больше), <=(меньше или равно), >=(больше или равно).

В условных конструкциях можно использовать else и else-if/else-unless
и сложные подстановки::

  {city.name} &mdash;
  {if city.name == 'Москва'}
      порт семи морей
  {else-if city.name == 'Киев'}
      мать городов русских
  {else-unless city.name == 'Владивосток'}
      какой-то город, но точно не Владивосток
  {/if}

Шаблонизатор понимает специальну конструкцию if[-not]-empty,
которая позволяет определить, пустой ли масси или объект.
Объект считается пустым, если у него нет ни одного свойства.

``{if-empty list} В списке list нет ни одного пункта {/if}``

Циклы
-----

Цикл позволяет пройтись по всем элементам массива или по всем свойствам объекта.
В теле цикла ```$``` будет указывать на значение текущего элемента массива
или значение текущего свойства объекта.
Простейший пример использования цикла для вывода массива как HTML-списка::

  <ul>
    {each array}
      <li>{$}</li>
    {/each}
  </ul>

При подстановке данных ['первый элемент',2,'<b>третий элемент</b>'] в шаблон, получим::

  <ul>
      <li>первый элемент</li>
      <li>2</li>
      <li><b>третий элемент</b></li>
  </ul>

В теле цикла доступны локальные переменные:

+ ``{$i}`` - порядковый номер элемента или свойства (нумерация начинается с нуля);
+ ``{$k}`` - ключ свойства или номер элемента для массива;
+ ``{$$}`` - ссылается на текущий массив или объект, по которому происходит итерация.

При обходе массива в теле цикла доступны специальные условные конструкции:

+ ``{if-first} если текущий элемент первый в массиве, то этот текст появится в результате {/if}``
+ ``{if-last} если текущий элемент последний в массиве, то этот текст появится в результате {/if}``

Использование этих конструкций при обходе объекта может привести к неожиданным результатам.

Во вложенных циклах может потребоваться доступ во внутреннем цикле к значению, индексу или ключу из внешнего цикла.
Для этого достаточно назначить алиасы для интересующих переменных во внешнем цикле и обращаться к ним, используя подстановки::

  data = {
    stations: [
      {name: 'Владивосток', id: 'vl'},
      {name: 'Нью-Йорк',    id: 'ny'},
      {name: 'Париж',       id: 'pa'}
    ],
    distance: {
      vl: {vl: 0,   ny: 10, pa: 100},
      ny: {vl: 10,  ny: 0,  pa: 80},
      pa: {vl: 100, ny: 80, pa: 0}
    }
  };

  <h1>Расстояние между населенными пунктами</h1>
  <table>
    <tr>
      <td />
      {each stations}
        <td>{$.name}</td>
      {/each}
    </tr>
    {each station in stations}
      <tr>
        <td>{$.name}</td>
        {each stations}
          <td>{distance[$.id][station.id]}</td>
        {/each}
      </tr>
    {/each}
  </table>

Пример выводит табличку с расстояниями между городами.
Полный синтаксис цикла::

  {each [element[ as key][ at index] in ]array_or_hash}
    ...тело цикла...
  {/each}

, где необязательные параметры:

+ ``element`` - алиас для ``$``,
+ ``key`` - алиас для ``$k``,
+ ``index`` - алиас для ``$i``.

Дополнительно
^^^^^^^^^^^^^

При загрузке страницы библиотека ищет теги